# Тестовое задание 
## Выполнил: Илларионов Георгий

### Техническое задание
<details>
  <summary>Показать</summary>
  
#### Запуск приложения:
 - npm ci
 - npm start (запустится Storybook)

#### Общая цель:
Замаскировать html-фрагмент, чтобы его нельзя было идентифицировать с помощью XPath или регулярных выражений (поэтому классы у элементов генерируются динамически при каждой отрисовки). 

#### Нужно сделать:
 1. Обновить компонент **src/components/base/Image.tsx** таким образом, чтобы он отрисовывал изображение с помощью тега div (с class="..."), а не img;
 2. Обновить компонент **src/components/base/SmokeText.tsx** таким образом, чтобы он динамически маскировал выдаваемую строку (обезопасить от возможности найти блок с помощью XPath или регулярного выражения при следующей перерисовки);
 3. Написать тесты на алгоритм, который реализует функциональность в **src/components/base/SmokeText.tsx**;

Примеры XPath и регулярных выражений, от которых необходимо защититься, можно увидеть в **.storybook/components/RenderComponent.tsx**.

</details>

### Комментарий для проверяющего

#### Что сделано? 
1. Для запуска на `nodejs v18` изменен стартовый скрипт \
   ``export SET NODE_OPTIONS=--openssl-legacy-provider``

2. Изменен компонент `Image.tsx` (замена `<img>` на `<div class='...'>`) \
   **Идея:** 
   - Создать `<style>`, содержащий css селектор (класс) с уникальным именем (использована функция `cid()` из `lib/smokescreen/Cid.js`) и атрибутом `content: url(<image_src>)`
   - Передать этот класс в проп `className` у `div`
    <details>
        <summary><b>Рассмотренные альтернативы</b></summary>
      1. inline style с <i>content: url(...)`</i><br>
          - Не подходит по тз<br>
      2. ref + useEffect + style.content = url(...)<br>
          - Тот же inline, не по ТЗ<br>
      3. Использовать styled-components: <br>
          - Доп. зависимость <br>
          - Имена классов не меняются после перерисовки <br>
      4. canvas<br>
          - Не по ТЗ<br>
          - Сложно добавлять стили и анимации 
    </details>

   **Кроме того** \
   Заметил, что на картинку изначально были навешены стили по тегу `img` \
   Решение: заменил селектор в `styles.ts` на `.img`, замаскировал стиль через `transform('img')` и передал в `<Image>`. Для этого в `Image.tsx` был добавлен новый проп `className`
3. Изменен компонент `SmokeText.tsx` (динамическое маскирование строки) \
   **Идея:**
   - Создать утилиту `mask()`, которая: 
     - Заменит кириллические символы на другие похожие
        > Например `а`(кириллица) -> `a`(латиница)
     - Добавить невидимые символы (использован `Zero-width non-joiner (ZWNJ)`) между буквами
   - Использовать `mask()` в компоненте
    <details>
    <summary><b>Рассмотренные альтернативы</b></summary>
    1. Спрятать текст в canvas <br>
        - Сложности с шрифтами и управлением размерами блока <br>
        - Сложности с переносом слов <br>
        - Трудно или невозможно менять стили (например при hover) <br>
    2. Превратить текст в картинку <br>
        - Недостатки аналогичны п.1 <br>
    3. Использовать реверс строки целиком/случайных частей + отрисовки rtl ltr <br>
        - Проблемы с пробелами(отсутствуют) и кавычками(перевёрнуты) <br>
        - Баги при отображении (например кусок слова улетел в конец предложения) <br>
    </details>

    **Кроме того** \
    Заметил, что регулярка с *москва* срабатывает, хотя тесты проходят: \
    Решение: обернул все текстовые поля в `main/left/teaser/index.tsx` в `<SmokeText>`
4. Написаны юнит тесты на утилиту `mask()` с использованием `jest`
   - Обновлен **typescript** до **v3.8.3**
   - Установлен **ts-jest 26.x.x**
   - Конфиг `jest.config.js`:
     - Среда: jsdom
     - Обработчик: ts-jest
   - <details>
        <summary>
            Добавлены прочие зависимости, из-за которых ломалась сборка
        </summary>
            "@types/babel__core": "7.1.18", <br>
            "@types/babel__traverse": "7.14.2", <br>
            "@types/prettier": "2.6.0",
     </details>
    **Проверены случаи:**
    1. Русские слова
    2. Английские слова
    3. Числа и символы
    4. Разный результат при повторном маскировании
    5. Обработка послевательностей `&#<code>;` и `&<code>;`
   